/******************************************************************************/
/* Include necessory packages                                                 */

include "output/utils.sk";
include "output/SummationArray.sk";
include "output/output0.sk";
include "output/kvpair_list_int0.sk";


/******************************************************************************/
/* Global Control Variables                                                   */
int mapKeyType = ??(1);

// Input variables decl
bit loop0;

/******************************************************************************/
/* Main function to verify the two results generated are equal                */

harness void main(int[5] intSet){
	// Initialize output variables.
	int sum0 = 0;
	int sum = intSet[4];

	// Initialize input data and variables
    int[3] data;
	data[0] = intSet[3];
	data[1] = intSet[2];
	data[2] = intSet[1];
	
    // Initialize input broadcast variables
    loop0 = false;
	
    // Initialize loop counters
    int i0 = 0;
	int i = intSet[0];

	// Verification code
	assert loopInvariant(data,0,0,0,0);
	if(loopInvariant(data,sum,0,i,0) && (i<3)) {
		int ind_sum = sum;
		ind_sum = (sum+data[i]);
		int ind_i = i;
		ind_i = (i+1);
		assert loopInvariant(data,ind_sum,0,ind_i,0);
	}
	if(loopInvariant(data,sum,0,i,0) && !(i<3)) {
		assert postCondition(data,sum,0,i,0);
	}
}

/******************************************************************************/
/* Verification functions                                                     */

bit postCondition(int[3] data, int sum, int sum0, int i, int i0){
	Output resMR = collect(reduce(map(data,i0,i)), sum0);
	return resMR.sum == sum;
}

bit loopInvariant(int[3] data, int sum, int sum0, int i, int i0){
	Output resMR = collect(reduce(map(data,i0,i)), sum0);
	return resMR.sum == sum && 0 <= i && i <= 3;
}

/******************************************************************************/
/* MapReduce Implementation                                                   */

generator int intMapGenerator(int[3] data, int i){
	int _terminal1 = {| ?? | i | data[i] |};
	int _terminal2 = {| ?? | i | data[i] |};
	int _option0 = _terminal1;
	int _option1 = _terminal1 + _terminal2;
	return {| _option0 | _option1 |};
}

generator int stringMapGenerator(int[3] data, int i){
	int _terminal1 = {| -1 |};
	int _terminal2 = {| -1 |};
	int _option0 = _terminal1;
	return {| _option0 |};
}



List do_map(int[3] data, int i){
	List result = new List();

	if(mapKeyType == 0){
		Pair kvp = new Pair();
		kvp.intkey = intMapGenerator(data, i);
		kvp.value = intMapGenerator(data, i);
		intlist_put(result, kvp);
	}
	else if(mapKeyType == 1){
		Pair kvp = new Pair();
		kvp.stringkey = stringMapGenerator(data, i);
		kvp.value = intMapGenerator(data, i);
		stringlist_put(result, kvp);
	}
	

	return result;
}

generator int intReduceGenerator(int val1, int val2){
	int terminal1 = {| ?? | val1 | val2 |};
	int terminal2 = {| ?? | val1 | val2 |};
	int _option0 = terminal2;
	int _option1 = terminal2 + terminal1;
	return {| _option0 | _option1 |};
}

Pair do_reduce(ListNode values){
	Pair p = new Pair();

	if(values == null)
		return p;

	if(mapKeyType == 0){
		p.intkey = values.intkey;
		p.intkey2 = values.intkey2;
	}
	else if(mapKeyType == 1){
		p.intkey = values.intkey;
		p.stringkey = values.stringkey;
	}

	p.value = {| 0 | 1 |};
	while(values != null){
		p.value = intReduceGenerator(p.value, values.value);
		values = values.next;
	}

	return p;
}

// Calls do_map on each index of the collection
// Equivelant to flatmap() in functional programming
List map(int[3] data, int i0, int i){
	List result = new List(handle = null);
	
	int _i = i0;
	
	while((_i<i) && (_i<3)){
		
		List kvPairs = do_map(data, _i);
		
		if(mapKeyType == 0){
			intlist_merge(result, kvPairs);
		}
		else if(mapKeyType == 1){
			stringlist_merge(result, kvPairs);
		}

		_i = (_i+1);
	
	}
	return result;
}

// Groups kvPairs by key and calls do_reduce for each key-values pair
// Equivelant to reduce() in functional programming
List reduce(List kvPairs){
	List result = new List(handle = null);
	
	// If map did not emit anything, we are done.
	if(kvPairs.handle == null) return result;

	// Create value arrays by grouping on keys and run reduce function for 
	// each key
	ListNode ptr_st = kvPairs.handle;
	ListNode ptr_end = kvPairs.handle;

	while(ptr_end.next != null){
		if( (mapKeyType == 0 && ptr_end.next.intkey == ptr_st.intkey && ptr_end.next.intkey2 == ptr_st.intkey2) 		||
		    (mapKeyType == 1 && ptr_end.next.intkey == ptr_st.intkey && ptr_end.next.stringkey == ptr_st.stringkey) )
		{
			ptr_end = ptr_end.next;
		}
		else{
			// break chain
			ListNode ptr_temp = ptr_end.next;
			ptr_end.next = null;

			// Run for this key
			Pair kv = do_reduce(ptr_st);
			if(mapKeyType == 0){
				intlist_insert(result,kv);
			}
			else if(mapKeyType == 1){
				stringlist_insert(result,kv);
			}
			
			// Reset for next key
			ptr_st = ptr_temp;
			ptr_end = ptr_temp;
		}
	}

	// Run for last key
	Pair kv = do_reduce(ptr_st);
	if(mapKeyType == 0){
		intlist_insert(result,kv);
	}
	else if(mapKeyType == 1){
		stringlist_insert(result,kv);
	}

	return result;
}

Output collect(List resMR, int sum0){
	Output output = new Output();

	if(mapKeyType == 0){
		output.sum = int_get(resMR,0,sum0);
	}
	else if(mapKeyType == 1){
		output.sum = string_get(resMR,0,sum0);
	}

	return output;
}