/******************************************************************************/
/* Include necessory packages                                                 */

include "output/utils.sk";
include "output/YelpKids2.sk";
include "output/Restaurant.sk";

/******************************************************************************/
/* Global Control Variables                                                   */
int CASPER_NUM_OUTVARS = 1;

bit[2] reduceExp0 = {false};
bit[3] _term_flag_int_terminal1_reduce0 = {false};
bit[4] _term_flag_string_terminal1_map_k0 = {false};
bit[2] mapExp_v0 = {false};
bit[1] mapExp_k0 = {false};
bit[3] _term_flag_int_terminal0_map_v0 = {false};
bit[3] _term_flag_int_terminal0_map_c0 = {false};
bit[3] _term_flag_int_terminal1_map_c0 = {false};
bit[4] _term_flag_string_terminal0_map_c0 = {false};
bit[2] _term_flag_bit_terminal0_map_c0 = {false};
bit[2] _term_flag_bit_terminal1_map_c0 = {false};
bit[3] _term_flag_int_terminal0_reduce0 = {false};
bit[4] _term_flag_string_terminal0_map_k0 = {false};
bit[4] _term_flag_string_terminal1_map_c0 = {false};
bit[3] _term_flag_int_terminal1_map_v0 = {false};
bit[1] mapExp_c0 = {false};


// Input variables decl

/******************************************************************************/
/* Main function to verify the two results generated are equal                */

harness void main(bit[3] bitSet, int[17] intSet, int csg_test_val1, int csg_test_val2){
	// Initialize output variables.
	int[4] result0;
	result0[0] = 0;
	result0[1] = 0;
	result0[2] = 0;
	result0[3] = 0;
	int[4] result;
	result[0] = intSet[16];
	result[1] = intSet[15];
	result[2] = intSet[14];
	result[3] = intSet[13];

	// Initialize input data and variables
    Restaurant[3] data;
	data[0] = new Restaurant();
	data[0].goodForKids = bitSet[2];
	data[0].score = intSet[12];
	data[0].comment = intSet[11];
	data[0].city = intSet[10];
	data[0].state = intSet[9];
	data[1] = new Restaurant();
	data[1].goodForKids = bitSet[1];
	data[1].score = intSet[8];
	data[1].comment = intSet[7];
	data[1].city = intSet[6];
	data[1].state = intSet[5];
	data[2] = new Restaurant();
	data[2].goodForKids = bitSet[0];
	data[2].score = intSet[4];
	data[2].comment = intSet[3];
	data[2].city = intSet[2];
	data[2].state = intSet[1];
	
    // Initialize input broadcast variables
    CASPER_TRUE = true;
    CASPER_FALSE = false;
    
    // Initialize loop counters
    int casper_index0 = 0;
	int casper_index = intSet[0];

	// Verification code
	assert loopInvariant(data,result0,result0,casper_index0,casper_index0);
	if(loopInvariant(data,result,result0,casper_index,casper_index0) && (casper_index<3)) {
		int[4] ind_result = result;
		if((!(result[data[casper_index].city]!=0))){
			ind_result[data[casper_index].city] = 0;
		if(data[casper_index].goodForKids){
			ind_result[data[casper_index].city] = (result[data[casper_index].city]+1);
		} else {
			ind_result = ind_result;
		}
		;
		} else {
			if(data[casper_index].goodForKids){
			ind_result[data[casper_index].city] = (result[data[casper_index].city]+1);
		} else {
			ind_result = ind_result;
		}
		}
		int ind_casper_index = casper_index;
		ind_casper_index = (casper_index+1);
		assert loopInvariant(data,ind_result,result0,ind_casper_index,casper_index0);
		
		if(mapExp_c0[0] && mapExp_k0[0] && mapExp_v0[0] && reduceExp0[1]) assert false;
		
	}
	if(loopInvariant(data,result,result0,casper_index,casper_index0) && !(casper_index<3)) {
		assert postCondition(data,result,result0,casper_index,0);
	}

	assert (reduce_result(csg_test_val1,csg_test_val2) == reduce_result(csg_test_val2,csg_test_val1)) || (reduce_result(csg_test_val1,csg_test_val2) == csg_test_val2 && reduce_result(csg_test_val2,csg_test_val1) == csg_test_val1);
	
}

/******************************************************************************/
/* Verification functions                                                     */

bit postCondition(Restaurant[3] data, int[4] result, int[4] result0, int casper_index, int casper_index0){
	int [4] casper_r;
	casper_r[0] = result[0];
	casper_r[1] = result[1];
	casper_r[2] = result[2];
	casper_r[3] = result[3];
	return reduce(data, result, result0, casper_index, casper_index0) == casper_r;
}

bit loopInvariant(Restaurant[3] data, int[4] result, int[4] result0, int casper_index, int casper_index0){
	int [4] casper_r;
	casper_r[0] = result[0];
	casper_r[1] = result[1];
	casper_r[2] = result[2];
	casper_r[3] = result[3];
	return casper_index0 <= casper_index && casper_index <= 3 && reduce(data, result, result0, casper_index, casper_index0) == casper_r;
}

/******************************************************************************/
/* MapReduce Implementation                                                   */

generator bit booleanMapGenerator_c0(Restaurant[3] data, int casper_index){
	bit _bit_terminal0;
	int  _bit_terminal0c = ??(1);
	if(_bit_terminal0c == 0) { _term_flag_bit_terminal0_map_c0[0] =  true; _bit_terminal0 = data[casper_index].goodForKids; }
	else if(_bit_terminal0c == 1) { _term_flag_bit_terminal0_map_c0[1] =  true; _bit_terminal0 = CASPER_FALSE; }
	else { assert false; }
	bit _bit_terminal1;
	int  _bit_terminal1c = ??(1);
	if(_bit_terminal1c == 0) { _term_flag_bit_terminal1_map_c0[0] =  true; _bit_terminal1 = data[casper_index].goodForKids; }
	else if(_bit_terminal1c == 1) { _term_flag_bit_terminal1_map_c0[1] =  true; _bit_terminal1 = CASPER_FALSE; }
	else { assert false; }
	int _string_terminal0;
	int  _string_terminal0c = ??(2);
	if(_string_terminal0c == 0) { _term_flag_string_terminal0_map_c0[0] =  true; _string_terminal0 = data[casper_index].comment; }
	else if(_string_terminal0c == 1) { _term_flag_string_terminal0_map_c0[1] =  true; _string_terminal0 = data[casper_index].city; }
	else if(_string_terminal0c == 2) { _term_flag_string_terminal0_map_c0[2] =  true; _string_terminal0 = data[casper_index].state; }
	else if(_string_terminal0c == 3) { _term_flag_string_terminal0_map_c0[3] =  true; _string_terminal0 = ??; }
	else { assert false; }
	int _string_terminal1;
	int  _string_terminal1c = ??(2);
	if(_string_terminal1c == 0) { _term_flag_string_terminal1_map_c0[0] =  true; _string_terminal1 = data[casper_index].comment; }
	else if(_string_terminal1c == 1) { _term_flag_string_terminal1_map_c0[1] =  true; _string_terminal1 = data[casper_index].city; }
	else if(_string_terminal1c == 2) { _term_flag_string_terminal1_map_c0[2] =  true; _string_terminal1 = data[casper_index].state; }
	else if(_string_terminal1c == 3) { _term_flag_string_terminal1_map_c0[3] =  true; _string_terminal1 = ??; }
	else { assert false; }
	int _int_terminal0;
	int  _int_terminal0c = ??(2);
	if(_int_terminal0c == 0) { _term_flag_int_terminal0_map_c0[0] =  true; _int_terminal0 = casper_index; }
	else if(_int_terminal0c == 1) { _term_flag_int_terminal0_map_c0[1] =  true; _int_terminal0 = data[casper_index].score; }
	else if(_int_terminal0c == 2) { _term_flag_int_terminal0_map_c0[2] =  true; _int_terminal0 = ??; assert _int_terminal0 != 0; }
	else { assert false; }
	int _int_terminal1;
	int  _int_terminal1c = ??(2);
	if(_int_terminal1c == 0) { _term_flag_int_terminal1_map_c0[0] =  true; _int_terminal1 = casper_index; }
	else if(_int_terminal1c == 1) { _term_flag_int_terminal1_map_c0[1] =  true; _int_terminal1 = data[casper_index].score; }
	else if(_int_terminal1c == 2) { _term_flag_int_terminal1_map_c0[2] =  true; _int_terminal1 = ??; assert _int_terminal1 != 0; }
	else { assert false; }
	int c = ??(0);
	if(c==0){ mapExp_c0[0]=true; return (_bit_terminal0); }
	else { assert false; }
	
}

generator int stringMapGenerator_k0(Restaurant[3] data, int casper_index){
	int _string_terminal0;
	int  _string_terminal0c = ??(2);
	if(_string_terminal0c == 0) { _term_flag_string_terminal0_map_k0[0] =  true; _string_terminal0 = data[casper_index].comment; }
	else if(_string_terminal0c == 1) { _term_flag_string_terminal0_map_k0[1] =  true; _string_terminal0 = data[casper_index].city; }
	else if(_string_terminal0c == 2) { _term_flag_string_terminal0_map_k0[2] =  true; _string_terminal0 = data[casper_index].state; }
	else if(_string_terminal0c == 3) { _term_flag_string_terminal0_map_k0[3] =  true; _string_terminal0 = ??; }
	else { assert false; }
	int _string_terminal1;
	int  _string_terminal1c = ??(2);
	if(_string_terminal1c == 0) { _term_flag_string_terminal1_map_k0[0] =  true; _string_terminal1 = data[casper_index].comment; }
	else if(_string_terminal1c == 1) { _term_flag_string_terminal1_map_k0[1] =  true; _string_terminal1 = data[casper_index].city; }
	else if(_string_terminal1c == 2) { _term_flag_string_terminal1_map_k0[2] =  true; _string_terminal1 = data[casper_index].state; }
	else if(_string_terminal1c == 3) { _term_flag_string_terminal1_map_k0[3] =  true; _string_terminal1 = ??; }
	else { assert false; }
	int c = ??(0);
	if(c==0){ mapExp_k0[0]=true; return (_string_terminal0); }
	else { assert false; }
	
}

generator int intMapGenerator_v0(Restaurant[3] data, int casper_index){
	int _int_terminal0;
	int  _int_terminal0c = ??(2);
	if(_int_terminal0c == 0) { _term_flag_int_terminal0_map_v0[0] =  true; _int_terminal0 = casper_index; }
	else if(_int_terminal0c == 1) { _term_flag_int_terminal0_map_v0[1] =  true; _int_terminal0 = data[casper_index].score; }
	else if(_int_terminal0c == 2) { _term_flag_int_terminal0_map_v0[2] =  true; _int_terminal0 = ??; assert _int_terminal0 != 0; }
	else { assert false; }
	int _int_terminal1;
	int  _int_terminal1c = ??(2);
	if(_int_terminal1c == 0) { _term_flag_int_terminal1_map_v0[0] =  true; _int_terminal1 = casper_index; }
	else if(_int_terminal1c == 1) { _term_flag_int_terminal1_map_v0[1] =  true; _int_terminal1 = data[casper_index].score; }
	else if(_int_terminal1c == 2) { _term_flag_int_terminal1_map_v0[2] =  true; _int_terminal1 = ??; assert _int_terminal1 != 0; }
	else { assert false; }
	int c = ??(1);
	if(c==0){ mapExp_v0[0]=true; return (_int_terminal0); }
	else if(c==1){ mapExp_v0[1]=true; return ((_int_terminal0) + (_int_terminal1)); }
	else { assert false; }
	
}



void map (Restaurant[3] data, int casper_index, ref int[CASPER_NUM_OUTVARS] keys0, ref int[CASPER_NUM_OUTVARS] keys1, ref int[CASPER_NUM_OUTVARS] values0)
{
  	if(booleanMapGenerator_c0(data, casper_index)){
		keys0[0] = ??;
		keys1[0] = stringMapGenerator_k0(data, casper_index);
		values0[0] = intMapGenerator_v0(data, casper_index);
	}
}

generator int intReduceGenerator0(int val1, int val2){
	int _int_terminal0;
	int  _int_terminal0c = ??(2);
	if(_int_terminal0c == 0) { _term_flag_int_terminal0_reduce0[0] =  true; _int_terminal0 = val1; }
	else if(_int_terminal0c == 1) { _term_flag_int_terminal0_reduce0[1] =  true; _int_terminal0 = val2; }
	else if(_int_terminal0c == 2) { _term_flag_int_terminal0_reduce0[2] =  true; _int_terminal0 = ??; assert _int_terminal0 != 0; }
	else { assert false; }
	int _int_terminal1;
	int  _int_terminal1c = ??(2);
	if(_int_terminal1c == 0) { _term_flag_int_terminal1_reduce0[0] =  true; _int_terminal1 = val1; }
	else if(_int_terminal1c == 1) { _term_flag_int_terminal1_reduce0[1] =  true; _int_terminal1 = val2; }
	else if(_int_terminal1c == 2) { _term_flag_int_terminal1_reduce0[2] =  true; _int_terminal1 = ??; assert _int_terminal1 != 0; }
	else { assert false; }
	int c = ??(1);
	if(c==0){ reduceExp0[0]=true; return (_int_terminal0); }
	else if(c==1){ reduceExp0[1]=true; return ((_int_terminal0) + (_int_terminal1)); }
	else { assert false; }
	
}



int init_result(int result0){
	return {| 0 | 1 | result0 |};
}

int reduce_result(int val1, int val2){
	return intReduceGenerator0(val1, val2);
}

int merge_result(int val1, int val2){
	return {| val1 | val1+val2 |};
}


int [4] reduce (Restaurant[3] data, int[4] result, int[4] result0, int casper_index, int casper_index0) {
	int [4] casper_r;
	casper_r[0] = init_result(result0[0]);
	casper_r[1] = init_result(result0[1]);
	casper_r[2] = init_result(result0[2]);
	casper_r[3] = init_result(result0[3]);
	
	for (int casper_i = casper_index0; casper_i < casper_index; ++casper_i)
	{
		int[CASPER_NUM_OUTVARS] keys0;
		int[CASPER_NUM_OUTVARS] keys1;
		int[CASPER_NUM_OUTVARS] values0;
		
		int num_pairs = CASPER_NUM_OUTVARS;

		map(data, casper_i, keys0, keys1, values0);

		for (int casper_j = 0; casper_j < num_pairs; ++casper_j)
		{ 
	  		int key0 = keys0[casper_j];
			int key1 = keys1[casper_j];
			
	  		if(key0 == 0) {	}
	  		else if (key0 == 1 && key1 == 0){ casper_r[0] = reduce_result(casper_r[0], values0[casper_j]); }
			else if (key0 == 1 && key1 == 1){ casper_r[1] = reduce_result(casper_r[1], values0[casper_j]); }
			else if (key0 == 1 && key1 == 2){ casper_r[2] = reduce_result(casper_r[2], values0[casper_j]); }
			else if (key0 == 1 && key1 == 3){ casper_r[3] = reduce_result(casper_r[3], values0[casper_j]); }
			
	  		else{ assert 0; }
		} 
	}

	casper_r[0] = merge_result(casper_r[0],result0[0]);
	casper_r[1] = merge_result(casper_r[1],result0[1]);
	casper_r[2] = merge_result(casper_r[2],result0[2]);
	casper_r[3] = merge_result(casper_r[3],result0[3]);
	

	return casper_r;
}
