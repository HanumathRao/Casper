/******************************************************************************/
/* Include necessory packages                                                 */

include "output/utils.sk";
include "output/StringMatch.sk";
include "output/output0.sk";
include "output/kvpair_list_bit0.sk";


/******************************************************************************/
/* Global Control Variables                                                   */
int mapKeyType = ??(1);

// Input variables decl
bit loop0;
int key1;
int key2;
int key3;

/******************************************************************************/
/* Main function to verify the two results generated are equal                */

harness void main(bit[3] bitSet, int[4] intSet){
	// Initialize output variables.
	bit foundKey30 = false;
	bit foundKey3 = bitSet[2];
	bit foundKey20 = false;
	bit foundKey2 = bitSet[1];
	bit foundKey10 = false;
	bit foundKey1 = bitSet[0];

	// Initialize input data and variables
    int[3] words;
	words[0] = intSet[3];
	words[1] = intSet[2];
	words[2] = intSet[1];
	
    // Initialize input broadcast variables
    loop0 = false;
	key1 = 2;
	key2 = 1;
	key3 = 0;
	
    // Initialize loop counters
    int i0 = 0;
	int i = intSet[0];

	// Verification code
	assert loopInvariant(words,false,false,false,false,false,false);
	if(loopInvariant(words,foundKey3,false,foundKey2,false,foundKey1,false) && (i<3)) {
		bit ind_foundKey3 = foundKey3;
		if(str_equal(key3,words[i])){
			ind_foundKey3 = true;
		} else {
			ind_foundKey3 = foundKey3;
		}
		bit ind_foundKey2 = foundKey2;
		if(str_equal(key2,words[i])){
			ind_foundKey2 = true;
		} else {
			ind_foundKey2 = foundKey2;
		}
		bit ind_foundKey1 = foundKey1;
		if(str_equal(key1,words[i])){
			ind_foundKey1 = true;
		} else {
			ind_foundKey1 = foundKey1;
		}
		assert loopInvariant(words,ind_foundKey3,false,ind_foundKey2,false,ind_foundKey1,false);
	}
	if(loopInvariant(words,foundKey3,false,foundKey2,false,foundKey1,false) && !(i<3)) {
		assert postCondition(words,foundKey3,false,foundKey2,false,foundKey1,false);
	}
}

/******************************************************************************/
/* Verification functions                                                     */

bit postCondition(int[3] words, bit foundKey3, bit foundKey30, bit foundKey2, bit foundKey20, bit foundKey1, bit foundKey10){
	Output resMR = collect(reduce(map(words,i0,i)), foundKey30, foundKey20, foundKey10);
	return resMR.foundKey3 == foundKey3 && resMR.foundKey2 == foundKey2 && resMR.foundKey1 == foundKey1;
}

bit loopInvariant(int[3] words, bit foundKey3, bit foundKey30, bit foundKey2, bit foundKey20, bit foundKey1, bit foundKey10){
	Output resMR = collect(reduce(map(words,i0,i)), foundKey30, foundKey20, foundKey10);
	return resMR.foundKey3 == foundKey3 && resMR.foundKey2 == foundKey2 && resMR.foundKey1 == foundKey1 && 0 <= i && i <= 3;
}

/******************************************************************************/
/* MapReduce Implementation                                                   */

generator int intMapGenerator(int[3] words, int i){
	int _terminal1 = {| ?? | i |};
	int _terminal2 = {| ?? | i |};
	int _option0 = _terminal1;
	return {| _option0 |};
}

generator int stringMapGenerator(int[3] words, int i){
	int _terminal1 = {| key3 | key2 | key1 | words[i] |};
	int _terminal2 = {| key3 | key2 | key1 | words[i] |};
	int _option0 = _terminal1;
	return {| _option0 |};
}



List do_map(int[3] words, int i){
	List result = new List();

	if(mapKeyType == 0){
		Pair kvp = new Pair();
		kvp.intkey = intMapGenerator(words, i);
		kvp.value = bitMapGenerator(words, i);
		intlist_put(result, kvp);
	}
	else if(mapKeyType == 1){
		Pair kvp = new Pair();
		kvp.stringkey = stringMapGenerator(words, i);
		kvp.value = bitMapGenerator(words, i);
		stringlist_put(result, kvp);
	}
	if(mapKeyType == 0){
		Pair kvp = new Pair();
		kvp.intkey = intMapGenerator(words, i);
		kvp.value = bitMapGenerator(words, i);
		intlist_put(result, kvp);
	}
	else if(mapKeyType == 1){
		Pair kvp = new Pair();
		kvp.stringkey = stringMapGenerator(words, i);
		kvp.value = bitMapGenerator(words, i);
		stringlist_put(result, kvp);
	}
	if(mapKeyType == 0){
		Pair kvp = new Pair();
		kvp.intkey = intMapGenerator(words, i);
		kvp.value = bitMapGenerator(words, i);
		intlist_put(result, kvp);
	}
	else if(mapKeyType == 1){
		Pair kvp = new Pair();
		kvp.stringkey = stringMapGenerator(words, i);
		kvp.value = bitMapGenerator(words, i);
		stringlist_put(result, kvp);
	}
	

	return result;
}

generator bit bitReduceGenerator(bit val1, bit val2){
	bit terminal1 = {| ?? | val1 | val2 | loop0 |};
	bit terminal2 = {| ?? | val1 | val2 | loop0 |};
	bit _option0 = terminal2;
	return {| _option0 |};
}

Pair do_reduce(ListNode values){
	Pair p = new Pair();

	if(values == null)
		return p;

	if(mapKeyType == 0){
		p.intkey = values.intkey;
		p.intkey2 = values.intkey2;
	}
	else if(mapKeyType == 1){
		p.intkey = values.intkey;
		p.stringkey = values.stringkey;
	}

	p.value = {| 0 | 1 |};
	while(values != null){
		p.value = bitReduceGenerator(p.value, values.value);
		values = values.next;
	}

	return p;
}

// Calls do_map on each index of the collection
// Equivelant to flatmap() in functional programming
List map(int[3] words, int i0, int i){
	List result = new List(handle = null);
	
	int _i = i0;
	
	while((_i<i) && (_i<3)){
		
		List kvPairs = do_map(words, _i);
		
		if(mapKeyType == 0){
			intlist_merge(result, kvPairs);
		}
		else if(mapKeyType == 1){
			stringlist_merge(result, kvPairs);
		}

		_i = (_i+1);
	
	}
	return result;
}

// Groups kvPairs by key and calls do_reduce for each key-values pair
// Equivelant to reduce() in functional programming
List reduce(List kvPairs){
	List result = new List(handle = null);
	
	// If map did not emit anything, we are done.
	if(kvPairs.handle == null) return result;

	// Create value arrays by grouping on keys and run reduce function for 
	// each key
	ListNode ptr_st = kvPairs.handle;
	ListNode ptr_end = kvPairs.handle;

	while(ptr_end.next != null){
		if( (mapKeyType == 0 && ptr_end.next.intkey == ptr_st.intkey && ptr_end.next.intkey2 == ptr_st.intkey2) 		||
		    (mapKeyType == 1 && ptr_end.next.intkey == ptr_st.intkey && ptr_end.next.stringkey == ptr_st.stringkey) )
		{
			ptr_end = ptr_end.next;
		}
		else{
			// break chain
			ListNode ptr_temp = ptr_end.next;
			ptr_end.next = null;

			// Run for this key
			Pair kv = do_reduce(ptr_st);
			if(mapKeyType == 0){
				intlist_insert(result,kv);
			}
			else if(mapKeyType == 1){
				stringlist_insert(result,kv);
			}
			
			// Reset for next key
			ptr_st = ptr_temp;
			ptr_end = ptr_temp;
		}
	}

	// Run for last key
	Pair kv = do_reduce(ptr_st);
	if(mapKeyType == 0){
		intlist_insert(result,kv);
	}
	else if(mapKeyType == 1){
		stringlist_insert(result,kv);
	}

	return result;
}

Output collect(List resMR, bit foundKey30, bit foundKey20, bit foundKey10){
	Output output = new Output();

	if(mapKeyType == 0){
		output.foundKey3 = int_get(resMR,0,foundKey30);
		output.foundKey2 = int_get(resMR,1,foundKey20);
		output.foundKey1 = int_get(resMR,2,foundKey10);
	}
	else if(mapKeyType == 1){
		output.foundKey3 = string_get(resMR,0,foundKey30);
		output.foundKey2 = string_get(resMR,1,foundKey20);
		output.foundKey1 = string_get(resMR,2,foundKey10);
	}

	return output;
}