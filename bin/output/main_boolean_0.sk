/******************************************************************************/
/* Include necessory packages                                                 */

include "output/utils.sk";
include "output/Equal.sk";

/******************************************************************************/
/* Global Control Variables                                                   */
int CASPER_NUM_OUTVARS = 1;

// Input variables decl
int val;
bit loop0;

/******************************************************************************/
/* Main function to verify the two results generated are equal                */

harness void main(bit[1] bitSet, int[5] intSet){
	// Initialize output variables.
	bit equal0 = true;
	bit equal = bitSet[0];

	// Initialize input data and variables
    int[3] data;
	data[0] = intSet[3];
	data[1] = intSet[2];
	data[2] = intSet[1];
	
    // Initialize input broadcast variables
    val = intSet[4];
	loop0 = false;
	
    // Initialize loop counters
    int i0 = 0;
	int i = intSet[0];

	// Verification code
	assert loopInvariant(data,true,true,0,0);
	if(loopInvariant(data,equal,true,i,0) && (i<3)) {
		bit ind_equal = equal;
		if((val!=data[i])){
			ind_equal = false;
		} else {
			ind_equal = equal;
		}
		int ind_i = i;
		ind_i = (i+1);
		assert loopInvariant(data,ind_equal,true,ind_i,0);
	}
	if(loopInvariant(data,equal,true,i,0) && !(i<3)) {
		assert postCondition(data,equal,true,i,0);
	}
}

/******************************************************************************/
/* Verification functions                                                     */

bit postCondition(int[3] data, bit equal, bit equal0, int i, int i0){
	bit [1] casper_r;
	casper_r[0] = equal;
	return reduce(data, equal, equal0, i, i0) == casper_r;
}

bit loopInvariant(int[3] data, bit equal, bit equal0, int i, int i0){
	bit [1] casper_r;
	casper_r[0] = equal;
	return 0 <= i && i <= 3 && reduce(data, equal, equal0, i, i0) == casper_r;
}

/******************************************************************************/
/* MapReduce Implementation                                                   */

generator bit bitMapGenerator(int[3] data, int i){
	bit _bit_terminal0 = {| loop0 |};
	bit _bit_terminal1 = {| loop0 |};
	int _int_terminal0 = {| i | val | data[i] |};
	int _int_terminal1 = {| i | val | data[i] |};
	bit _bit_terminal2 = {| true | false |};
	int _int_terminal2 = ??;
	int c = ??(2);
	if(c==0){ return _bit_terminal0; }
	if(c==1){ return _bit_terminal2; }
	if(c==2){ return (_bit_terminal0 != _bit_terminal1); }
	if(c==3){ return (_int_terminal0 != _int_terminal1); }
	
}

void map (int[3] data, int i, ref int[CASPER_NUM_OUTVARS] keys0, ref int[CASPER_NUM_OUTVARS] values0)
{
  	if(bitMapGenerator(data, i)){
		keys0[0] = ??;
		values0[0] = bitMapGenerator(data, i);
	}
}

generator bit bitReduceGenerator(bit val1, bit val2){
	bit _bit_terminal0 = {| val1 | val2 | loop0 |};
	bit _bit_terminal1 = {| val1 | val2 | loop0 |};
	int _int_terminal0 = {| val |};
	int _int_terminal1 = {| val |};
	bit _bit_terminal2 = {| true | false |};
	int _int_terminal2 = ??;
	int c = ??(2);
	if(c==0){ return _bit_terminal0; }
	if(c==1){ return _bit_terminal2; }
	if(c==2){ return (_bit_terminal0 != _bit_terminal1); }
	if(c==3){ return (_int_terminal0 != _int_terminal1); }
	
}

bit init_equal(){
	return {| true | false |};
}

bit reduce_equal(bit val1, bit val2){
	return bitReduceGenerator(val1, val2);
}

bit merge_equal(bit val1, bit val2){
	bit option1 = val1 || val2; bit option2 = val1 && val2; return {| val1 | option1 | option2 |};
}


bit [1] reduce (int[3] data, bit equal, bit equal0, int i, int i0) {
	bit [1] casper_r;
	casper_r[0] = init_equal();
	
	for (int casper_i = i0; casper_i < i; ++casper_i)
	{
		int[CASPER_NUM_OUTVARS] keys0;
		bit[CASPER_NUM_OUTVARS] values0;
		
		int num_pairs = CASPER_NUM_OUTVARS;

		map(data, casper_i, keys0, values0);

		for (int casper_j = 0; casper_j < num_pairs; ++casper_j)
		{ 
	  		int key0 = keys0[casper_j];
	
	  		if(key0 == 0) {	}
	  		else if (key0 == 1){ casper_r[0] = reduce_equal(casper_r[0], values0[casper_j]); }
	  		else{ assert 0; }
		} 
	}

	casper_r[0] = merge_equal(casper_r[0],equal0);
	

	return casper_r;
}